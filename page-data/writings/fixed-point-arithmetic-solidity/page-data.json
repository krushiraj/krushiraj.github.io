{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/writings/fixed-point-arithmetic-solidity/","result":{"data":{"mdx":{"id":"9b3ba437-60cc-5741-a372-e573eb526647","parent":{"sourceInstanceName":"content"},"excerpt":"Mastering Fixed Point Arithmetic in Solidity In the realm of blockchain and smart contract development, efficient and accurate arithmeticâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mastering Fixed Point Arithmetic in Solidity\",\n  \"date\": \"2023-12-23\",\n  \"type\": \"article\",\n  \"published\": true,\n  \"keywords\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"description\": \"An article that explores on why we would need a library to handle fixed point arithmetic in Solidity.\",\n  \"tags\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"banner\": \"./fixed-point-arithmetic.png\",\n  \"bannercaption\": \"Image from Google Images\",\n  \"technologies\": \"solidity,web3\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Mastering Fixed Point Arithmetic in Solidity\"), mdx(\"p\", null, \"In the realm of blockchain and smart contract development, efficient and accurate arithmetic operations are crucial. Solidity inherently supports integer arithmetic. However, there are scenarios where we require more precision, and this is where fixed point arithmetic enters the fray. \"), mdx(\"p\", null, \"Fixed point arithmetic allows for fractional calculations, bridging the gap between integer arithmetic\\u2019s limitations and the necessity for precision in certain calculations.\"), mdx(\"p\", null, \"Let\\u2019s delve into the FixedPointMathLib, one of the the libraries that facilitate fixed point arithmetic in Solidity , available on GitHub, source file located \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\"\n  }, \"here\"), \". To understand its core functionalities and how you can leverage it in your smart contract projects. We\\u2019ll try to understand what \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fixed Point Arithmetic\"), \" is and also go through some code in the library aforementioned.\"), mdx(\"h2\", null, \"Understanding Fixed Point Arithmetic\"), mdx(\"p\", null, \"In fixed point arithmetic, numbers are represented as integers, but a predefined scale factor indicates the decimal point\\u2019s position. For instance, if the scale factor is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \", the number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"12345\"), \" represents \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"123.45\"), \". This method allows for fractional computations while utilising integer arithmetic operations, thus maintaining a balance between precision and performance. The scale factor can change depending on our requirement for precision.\"), mdx(\"h2\", null, \"Why even use a Library for this?\"), mdx(\"p\", null, \"If you\\u2019re familiar with other programming languages then you would have already known that most of the languages support floating point and fixed point numbers by default with some data types. For example you can see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"float\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"double\"), \" types in C/C++. If you can remember we have no such data types in Solidity. That is for a reason, to put it simple it is due to the inconsistencies in the handling and implementation of fractional numbers on machines. Due to these inconsistencies, we might end up in multiple forks of the chain due to minor changes in data on chain.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Need to know more? Your rabbit hole starts \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ethereum.stackexchange.com/a/87235\"\n  }, \"here\"))), mdx(\"h2\", null, \"FixedPointMathLib\"), mdx(\"p\", null, \"Let us look into some functions what this library offers us.\"), mdx(\"h3\", null, \"mulWad\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function is designed to multiply two fixed point numbers. Here\\u2019s the function signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z)\\n\")), mdx(\"p\", null, \"Parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"b\"), \": The fixed point numbers to be multiplied.\")), mdx(\"p\", null, \"If you observe, we have something called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wad\"), \" in function name. That basically means that the scale factor here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10**18\"), \" (alleged origin of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wad\"), \" comes from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dapphub/ds-math/blob/master/README.md\"\n  }, \"here\"), \")\"), mdx(\"p\", null, \"The function employs Yul to perform the multiplication operation efficiently. By leveraging Yul, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function ensures that the multiplication is carried out with a low gas cost, which is crucial for blockchain operations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"/// @solidity memory-safe-assembly\\nassembly {\\n    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n    if mul(y, gt(x, div(not(0), y))) {\\n        mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n        revert(0x1c, 0x04)\\n    }\\n    z := div(mul(x, y), WAD)\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function first computes the product of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" using integer multiplication, then adjusts the result for the scale factor by dividing the product by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10 ** 18\"), \"(in the file at L51 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WAD\"), \" constant is defined). This way, the function yields the correct fixed point representation of the product.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"if mul(y, gt(x, div(not(0), y)))\\n\")), mdx(\"p\", null, \"If you observe the code checks for the overflow case and makes sure to revert the execution with error.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"not(0)\"), \" - bit wise negation results in the max int value. Ex: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x00\"), \" will be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xFF\"), \" when negated - let us assume this result as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"maxInt\"), \". Here it is actually max value a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"uint256\"), \" can take.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"div(not(0), y))\"), \" - now this will be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"div(maxInt, y)\"), \" - lets assume this as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"quotient\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), y))\"), \" - this will check if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x > quotient\"), \". Simple check to make sure that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x * y < maxInt\"), \". Lets assume this result as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"check\"), \", which can have a value of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD))))))\"), \" - simply means that verifying if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y * check\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" or not\")), mdx(\"p\", null, \"This makes it safe to avoid unexpected behaviour of the smart contracts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\nrevert(0x1c, 0x04)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mstore(0x00, 0xbac65e5b)\"), \": This line is storing the value \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xbac65e5b\"), \" at memory location \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x00\"), \". The value \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xbac65e5b\"), \" is likely the hash of the error message \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MulWadFailed()\"), \". Solidity uses the first 4 bytes of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"keccak-256\"), \" hash of the function signature to identify it. This is a common practice to save gas instead of storing the entire string error message.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"revert(0x1c, 0x04)\"), \": This line reverts the transaction. The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"revert\"), \" opcode takes two parameters: the first is the starting position in memory of the data to return, and the second is the size of this data in bytes. In this case, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1c\"), \" is the position in memory where the data starts, and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x04\"), \" is the size of the data to return. It means that when the transaction is reverted, it will return 4 bytes of data starting from the 28th byte (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1c\"), \" in hexadecimal) of memory.\")), mdx(\"h3\", null, \"mulWadUp\"), mdx(\"p\", null, \"This is similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" but the result is rounded up. For the other case it is rounded down\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mod(mul(x, y), WAD))\"), \"- check if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(x * y) % WAD == 0\"), \"- If it is zero, it means the product is perfectly divisible by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" and there\\u2019s no fractional part to consider for rounding\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(iszero(mod(mul(x, y), WAD)))\"), \": This double-negative check turns a true condition (non-zero modulus) into a false one and vice versa. So, if there is a non-zero fractional part, the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" function will return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" for non-zero and then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" again will turn that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\"), \": Adds the result of the double \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" check to the quotient of the product divided by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \". This effectively rounds up the result if there was a non-zero fractional part.\")), mdx(\"h3\", null, \"divWad\"), mdx(\"p\", null, \"Similarly, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"divWad\"), \" function facilitates division operations between fixed point numbers. Here\\u2019s the function signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function divWad(uint256 x, uint256 y) internal pure returns (uint256 z)\\n\")), mdx(\"p\", null, \"Parameters are similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \", with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" being the operands\"), mdx(\"p\", null, \"There are checks here as well, just like we do in other functions to make sure the results are not inconsistence or overflowed or underflowed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"assembly {\\n    // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n    if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n        mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n        revert(0x1c, 0x04)\\n    }\\n    z := div(mul(x, WAD), y)\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(WAD, gt(x, div(not(0), WAD)))\"), \": This performs a check to ensure that the value of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is not too large to be multiplied by the scaling factor \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" without causing an overflow. The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt\"), \" function checks if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is greater than the largest \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"uint256\"), \" divided by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is indeed greater, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \" indicating an overflow. If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is not greater, the result would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".    \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mul(WAD, gt(x, div(not(0), WAD))))\"), \": This is checking the result of the multiplication for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x <= uint256.max / WAD\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and multiplying by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" would still be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", resulting in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" returning \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" were too large, the result of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(WAD, 1)\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \", making \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))\"), \": This multiplies \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" with the result of the previous \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" check. If the previous result was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \", it implies that there is no risk of overflow when \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is multiplied by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \", and it proceeds to multiply \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \" (effectively leaving \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" unchanged). If the result was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", it means that there was a risk of overflow, and multiplying \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" would yield \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(...)\"), \": If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" or if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" was safe to multiply by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" without causing an overflow, then the entire multiplication expression would evaluate to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \". If there was a potential overflow detected, the multiplication result would not be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\")), mdx(\"p\", null, \"This is making sure that we make the calculations in the bounds and makes sure no unexpected behaviour happens if there is an overflow or underflow.\"), mdx(\"h3\", null, \"divWadUp\"), mdx(\"p\", null, \"This is similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"divWad\"), \" but the result is rounded up. For the other case it is rounded down. A similar approach to round up used in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWadUp\"), \" is being used here but with a different values.\"), mdx(\"h2\", null, \"How would this help?\"), mdx(\"h3\", null, \"Pros:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Precision\"), \": It offers higher precision for fractional numbers compared to integer arithmetic, which is crucial for financial computations that require decimal points.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Gas Efficiency\"), \": The library uses Yul, an intermediate language that compiles down to EVM bytecode, often leading to more gas-efficient contract execution than using Solidity alone.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Safety\"), \": It includes checks to prevent overflows and underflows, common pitfalls in smart contract development that can lead to significant vulnerabilities.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Convenience\"), \": Developers can perform arithmetic operations without implementing their own fixed-point math system, saving time and reducing the risk of errors.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Interoperability\"), \": It uses a standard format (wad) that is widely recognized in the Ethereum ecosystem, making it easier to integrate with other contracts and systems.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Transparency\"), \": The operations are transparent and verifiable, ensuring that contract behavior can be predicted and validated, which is essential for trust in DeFi applications.\")), mdx(\"h3\", null, \"Cons:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Complexity\"), \": For developers unfamiliar with fixed-point arithmetic, there may be a learning curve to understand how to properly use the library functions.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Code Size\"), \": Including an external library can increase the size of the contract bytecode, potentially leading to higher deployment costs.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Overhead\"), \": While the library is optimized for gas, using any library still adds a layer of complexity and gas overhead compared to native operations.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Limited Range\"), \": Fixed-point numbers have a limited range compared to floating-point numbers, which may be a limitation for some applications.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Specificity\"), \": The library is designed for a specific scaling factor (wad), which may not be suitable for all use cases requiring different levels of precision.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Upgradability\"), \": If the library is found to have a bug or requires an update, depending on how it\\u2019s integrated, it might be difficult to upgrade the smart contracts that use it.\")), mdx(\"h2\", null, \"Practical Applications\"), mdx(\"p\", null, \"These functions are indispensable when dealing with financial calculations, simulations, or any scenario demanding precision beyond integer arithmetic in your smart contracts. By understanding and utilising fixed point arithmetic through the FixedPointMathLib, you can ensure that your smart contracts operate accurately and efficiently, making your dApps more robust and reliable. Examples as follows:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"DeFi Yield Farming Platforms\"), \": Calculating rewards based on staking durations and amounts often requires precision to ensure users receive an accurate share of the yield.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Automated Market Makers (AMMs)\"), \": AMMs use complex formulas like the constant product formula (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x * y = k\"), \") for liquidity pools.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Token Vesting Contracts\"), \": When tokens are vested, they might be released continuously over time, which could require division to calculate the fraction of tokens to release at any given point.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Oracles\"), \": Price oracles that feed external data (like currency exchange rates) into the blockchain often require high precision. When these rates are used to determine transaction values or contract terms, fixed-point arithmetic helps maintain accuracy.\")), mdx(\"p\", null, \"Also other examples include \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Insurance Contracts\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bonding Curves\"), \",  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interest Rate Models\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stablecoin Pegs\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Financial Derivatives\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scientific Computations\"), \",  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Gaming and Gambling Contracts\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fractional NFTs\")), mdx(\"p\", null, \"In conclusion, FixedPointMathLib\\u2019s functions are vital tools in the toolkit of a Solidity developer aiming to tackle complex arithmetic scenarios in smart contract development. Through a deep understanding of these functions and fixed point arithmetic, you\\u2019re well on your way to mastering the mathematical underpinnings of Solidity and developing sophisticated smart contracts for the Ethereum blockchain.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Mastering Fixed Point Arithmetic in Solidity","date":"December 23, 2023","description":"An article that explores on why we would need a library to handle fixed point arithmetic in Solidity.","technologies":"solidity,web3","tags":"web3,math,arithmetic,fixedpoint,solidity","keywords":"web3,math,arithmetic,fixedpoint,solidity","banner":{"childImageSharp":{"fluid":{"tracedSVG":"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='400'%20height='246'%20viewBox='0%200%20400%20246'%20preserveAspectRatio='none'%3e%3cpath%20d='M4%206%203%20126v119h397V6L202%205%204%206m1%20119v118h393V7H5v118m20-77%201%2011h356V38H25v10m193-2c0%2013-1%2012%2013%2012h13V39h-26v7m27%202%201%2010h25V39h-26v9m28%200v10h25V39h-25v9m27%200v10h25V40l-12-1h-13v9m27%200v10h26V39h-26v9m28%200v10h26V40l-13-1h-13v9M54%2066c-1%200-1%201%201%202h3a2797%202797%200%200%201%20166%200%202879%202879%200%200%201%2077-3%20934449%20934449%200%200%201-247%201m125%2099%201%2071V95h183v141h-93a1517%201517%200%200%200%202%202h92V94H179v71m54-66v11l1%209h93V98h-46l-48%201m57%207%201%208%201%202%208%201h8v-17h-18v6m20%203v8h15v-17h-15v9M28%20123v10h149v-20H28v10m84-8h-8v7c0%209%201%2010%209%2010h7v-18l-8%201m10%208v9l8-1h8v-16h-16v8m26-8h-8v16h9l8%201v-18l-9%201m11%208v9l8-1h9v-16h-17v8m93%2011v10h75v-20h-75v10m38-1c0%209%201%2010%2010%209h7v-16h-17v7m20%201v8h7l8%201v-17h-15v8M28%20159v11h149v-21H28v10m76-1c0%2010%200%2010%209%2010h7v-17h-16v7m18%201v9h16v-17h-16v8m18%200v9h17v-17h-17v8m19%200v9h17v-17h-17v8M29%20190l-1%2010v9h149v-20h-74l-74%201m75%207c0%2010%201%2011%209%2011h7v-18h-16v7m18%202v9h16v-18h-16v9m18%200v9h17v-18h-17v9m19%200v9h17v-18h-17v9m22%2020v10h149v-20H181v10m76-1c0%209%201%2010%209%2010h7v-17h-16v7m18%202v8h16v-17h-16v9m18%200v8h17v-17h-17v9m19%200v8h16v-17h-16v9'%20fill='%23d3d3d3'%20fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":1.6304347826086956,"src":"/static/8e29b987aa6deb0185a44bd763f54af7/2a4de/fixed-point-arithmetic.png","srcSet":"/static/8e29b987aa6deb0185a44bd763f54af7/6d161/fixed-point-arithmetic.png 150w,\n/static/8e29b987aa6deb0185a44bd763f54af7/630fb/fixed-point-arithmetic.png 300w,\n/static/8e29b987aa6deb0185a44bd763f54af7/2a4de/fixed-point-arithmetic.png 600w,\n/static/8e29b987aa6deb0185a44bd763f54af7/e56b8/fixed-point-arithmetic.png 850w","srcWebp":"/static/8e29b987aa6deb0185a44bd763f54af7/ad85c/fixed-point-arithmetic.webp","srcSetWebp":"/static/8e29b987aa6deb0185a44bd763f54af7/e7487/fixed-point-arithmetic.webp 150w,\n/static/8e29b987aa6deb0185a44bd763f54af7/403a4/fixed-point-arithmetic.webp 300w,\n/static/8e29b987aa6deb0185a44bd763f54af7/ad85c/fixed-point-arithmetic.webp 600w,\n/static/8e29b987aa6deb0185a44bd763f54af7/5c1d9/fixed-point-arithmetic.webp 850w","sizes":"(max-width: 600px) 100vw, 600px"}}},"bannercaption":"Image from Google Images"},"fields":{"slug":"/writings/fixed-point-arithmetic-solidity/","timeToRead":{"minutes":10},"socialImage":{"childImageSharp":{"original":{"width":2400,"height":1254,"src":"/static/38b17cab9ead068b9866729e6d4a3f48-98315efa569325fabd78a76d6056a4bb.png"}}}}}},"pageContext":{"slug":"/writings/fixed-point-arithmetic-solidity/","previous":{"parent":{"name":"index","sourceInstanceName":"content"},"fields":{"slug":"/writings/fixed-point-vs-abdk-math/"},"frontmatter":{"title":"FixedPointMathLib vs ABDKMath64x64 - What should you use?","published":true,"type":"article"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"FixedPointMathLib vs ABDKMath64x64 - What should you use?\",\n  \"date\": \"2023-12-23\",\n  \"type\": \"article\",\n  \"published\": true,\n  \"keywords\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"description\": \"An article about which library to pick for fractional arithmetic in Solidity.\",\n  \"tags\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"banner\": \"./comparison.jpeg\",\n  \"bannercaption\": \"Image from Google Images\",\n  \"technologies\": \"solidity,web3\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"FixedPointMathLib vs ABDKMath64x64 - What should you use?\"), mdx(\"p\", null, \"In Solidity we don\\u2019t have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Fixed Point Arithmetic\"), \" out-of-the-box, hence we rely on various libraries to make it easier and safer for us. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\"\n  }, \"FixedPointMathLib\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\"\n  }, \"ABDKMath64x64\"), \" are some of the well known libraries that handle this.\"), mdx(\"p\", null, \"Lets see which one should you be using and why? There can be a lot of factor to support the decision of which one to use, we will go through a couple of things that matter and see which one has to be used based on the scenario that a smart contract developer has.\"), mdx(\"h2\", null, \"Differences\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Precision and Range\"), \":    \"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Operates with a 64.64 fixed point math library, meaning it uses 64 bits for the integer part and 64 bits for the fractional part. This allows for high precision and a wide range of numbers, but it can be more computationally intensive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": This library uses a different approach and have a different precision range with WAD factor which is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10**18\"), \".\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Performance\"), \":\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Known for high precision, but this can come at the cost of gas (when used in Ethereum smart contracts), as operations are more complex and you might have to keep converting the numbers from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"int\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"64x64\"), \" format.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": Less gas-intensive for certain operations as it relies on the Yul to make use of direct math functions mostly.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Use Cases\"), \":    \"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Its high precision makes it suitable for financial applications, complex calculations, and anywhere that a very small margin of error is critical.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": Good to use when we have simple calculations that can be done with in 18 decimal point precision. Most of the transactions of ERC20 and user facing data will be similar to this. So better for naive usage.\")))), mdx(\"h2\", null, \"Code in action\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"// SPDX-License-Identifier: MIT\\npragma  solidity  >=0.8.0;\\n\\nimport  \\\"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport  \\\"https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\\\";\\n\\nusing FixedPointMathLib for  uint256;\\nusing FixedPointMathLib for  int256;\\n\\nusing ABDKMath64x64 for  int128;\\n\\ncontract Math {\\n    function mul0(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        c = a * b;\\n    }\\n    \\n    function mul1(int128 a,  int128 b)  public  pure  returns  (int128 c)  {\\n        c = a.mul(b);\\n    }\\n    \\n    function mul2(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        int128 aFixed = ABDKMath64x64.fromUInt(a);\\n        int128 bFixed = ABDKMath64x64.fromUInt(b);\\n\\n        // Perform the calculation using ABDKMath64x64\\n        int128 rawResult = aFixed.mul(bFixed);\\n        \\n        // Convert the result back to uint for the return value\\n        c = ABDKMath64x64.toUInt(rawResult);\\n    }\\n\\n    function mul3(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        c = a.mulWad(b);\\n    }\\n\\n    function pow0(int256 a,  int256 b)  public  pure  returns  (int256 c)  {\\n        c = a.powWad(b);\\n    }\\n\\n    function pow1(int128 a,  uint256 b)  internal  pure  returns  (int128 c)  {\\n        c = a.pow(b);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This smart contract tries to make use of both the libraries to do some basic multiplication and then calculate power.\"), mdx(\"p\", null, \"Now we will try to execute each of those and see how each performs. We only care about inputs, outputs and gas here. So rest of logs are omitted here.\"), mdx(\"h3\", null, \"mul0\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to: Math.mul0(uint256,uint256)\\n\\nexecution cost\\n1049 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120\\\", \\\"uint256 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600\\\" }[]\\n\")), mdx(\"p\", null, \"This is direct multiplication in solidity without any help of libraries. Simple to understand inputs and output.\"), mdx(\"h3\", null, \"mul1\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul1(int128,int128) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1058 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int128 a\\\": \\\"120\\\", \\\"int128 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int128: c 0\\\" }[]\\n\")), mdx(\"p\", null, \"The output here is 0. Any idea about why is that 0?\\nIt is because the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" library expects the number to be in the form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\"), \" bit representation. That means we need to convert the number to binary and then add 64 bit of binary 0 to make fractional part 0 for that number. Lets do that for 120 and 130\\n| decimal | binary (without 64 zeros for fractional part) | decimal for 64.64 |\\n|----------|---------|------------------|\\n|120 | 1111000 | 2213609288845146193920 |\\n|130 | 10000010 | 2398076729582241710080 |\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul1(int128,int128) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1058 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int128 a\\\": \\\"2213609288845146193920\\\", \\\"int128 b\\\": \\\"2398076729582241710080\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int128: c 287769207549869005209600\\\" }[]\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"287769207549869005209600 = 111100111100000000000000000000000000000000000000000000000000000000000000000000 = 15600\")), mdx(\"h3\", null, \"mul2\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Math.mul2(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1351 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120\\\", \\\"uint256 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600\\\" }[]\\n\")), mdx(\"p\", null, \"This is using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \", but the catch here is we used extra helpers to convert instead of doing it all by ourselves like we did before. Hence extra gas cost.\"), mdx(\"h3\", null, \"mul3\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul3(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n877 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"128\\\", \\\"uint256 b\\\": \\\"128\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 0\\\" }[]\\n\")), mdx(\"p\", null, \"The same again, not the results we wanted to see. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \" expects a number with 18 decimal places i.e., we need to append 18 zeros after the number\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul3(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n877 gas (Cost only applies when called by a contract)[]\\n\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120000000000000000000\\\", \\\"uint256 b\\\": \\\"130000000000000000000\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600000000000000000000\\\" }[]\\n\")), mdx(\"p\", null, \"Now we get the correct output but with 18 zeros appended to it.\"), mdx(\"h3\", null, \"pow0\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.pow0(int256,int256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n2723 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int256 a\\\": \\\"2000000000000000000\\\", \\\"int256 b\\\": \\\"10000000000000000000\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int256: c 1023999999999999995727\\\" }[]\\n\")), mdx(\"p\", null, \"Uses the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \". I would expect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2 ** 10\"), \" to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1024\"), \". But the value here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1023.999.....5727\"), \" which is not correct but close when we round up.\"), mdx(\"h3\", null, \"pow1\"), mdx(\"p\", null, \"Users the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \". For conversion\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \" - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \" in binary and when converted to int with 64 bit decimal places, it is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"18446744073709551616\"), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \" - we give this directly as the power is expected in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int128\"), \" but not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.pow1(int128,uint256) 0xddaAd340b0f1Ef65169Ae5E41A8b10776a75482d[](https://remix.ethereum.org/#)\\n\\nexecution cost\\n\\n2302 gas (Cost only applies when called by a contract)[](https://remix.ethereum.org/#)\\n\\ninput\\n\\n0x9ea...0000a[](https://remix.ethereum.org/#)\\n\\ndecoded input\\n\\n{ \\\"int128 a\\\": \\\"36893488147419103232\\\", \\\"uint256 b\\\": \\\"10\\\" }[](https://remix.ethereum.org/#)\\n\\ndecoded output\\n\\n{ \\\"0\\\": \\\"int128: c 18889465931478580854784\\\" }[](https://remix.ethereum.org/#)\\n\")), mdx(\"p\", null, \"The output when converted to binary will give us \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000+64 zeros\"), \". Those 64 zeros can be omitted to get the integral part which then converts to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1024\"), \", the exact output for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2 ** 10\")), mdx(\"h3\", null, \"Gas costs\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ABDKMath64x64\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FixedPointMathLib\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"mul\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1058\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"877\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"pow\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2302\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2723\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If we include gas to convert for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" it would add around 300\")), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" is gas efficient for complex calculations and very precise and accurate for smaller integral numbers with large fractional part.\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \" is good with large numbers and has less precision for more complex calculations, but highly gas efficient for basic math.\"), mdx(\"p\", null, \"So, if you are building something that include complex formulae like bonding curve, exponential farming or anything that requires high precision and complex calculations one should go for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \", else if you require basic math with low precision which is mostly used in transfer, ERC20 related, more user facing applications and functions one should go for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \", as for user facing you don\\u2019t have to put in extra effort to convert it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\"), \"format when compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WAD\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"parent":{"name":"index","sourceInstanceName":"content"},"fields":{"slug":"/writings/erc-721-enumerable/"},"frontmatter":{"title":"Mastering ERC721 Enumerable","published":true,"type":"article"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mastering ERC721 Enumerable\",\n  \"date\": \"2023-12-23\",\n  \"type\": \"article\",\n  \"published\": true,\n  \"keywords\": \"web3,nft,erc721,erc721enumerable,enumerable,solidity\",\n  \"description\": \"An article about ERC721Enumerable and how is it helpful and different from base ERC721 standard.\",\n  \"tags\": \"web3,nft,erc721,erc721enumerable,enumerable,solidity,article\",\n  \"banner\": \"./erc-721-enumerable.jpg\",\n  \"bannercaption\": \"Image from Google Images\",\n  \"technologies\": \"solidity,web3\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"The ERC721 Enumerable\"), mdx(\"h2\", null, \"ERC721 Enumerable Intro\"), mdx(\"p\", null, \"We are well known for the fact that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ERC721\"), \" is the standard for the NFTs, which are used to represent the unique digital assets on the Ethereum Blockchain. In addition to that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ERC721 Enumerable\"), \" is an extension of ERC721 that enhances its capabilities by enabling efficient enumeration of NFTs for advanced tracking, management and optimal for the operations on the blockchain.\"), mdx(\"p\", null, \"ERC721 Enumerable is designed to track and enumerate tokens more effectively. It\\u2019s particularly useful for applications requiring knowledge of all tokens owned by an address or the total supply of tokens.\"), mdx(\"h2\", null, \"Using ERC721 Enumerable to create an NFT smart contract\"), mdx(\"p\", null, \"It is similar to the creation of an NFT smart contract using ERC721 but with some additional functions that we need to override so we can enjoy the benefits of ERC721 Enumerable.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You can learn how to implement and use ERC721 here\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Starting with Basic Setup:\"), \"\\nImport OpenZeppelin\\u2019s ERC721 and ERC721Enumerable contracts.\\nDeclare the contract and inherit from both ERC721 and ERC721Enumerable.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\n\\ncontract MyNFT is ERC721, ERC721Enumerable {\\n    // Your contract code goes here\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 2\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Override Required Functions.\"), \"\\nOverride functions from both ERC721 and ERC721Enumerable to ensure compatibility.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function _beforeTokenTransfer(address from, address to, uint256 tokenId)\\n    internal\\n    override(ERC721, ERC721Enumerable)\\n{\\n    super._beforeTokenTransfer(from, to, tokenId);\\n}\\n\\nfunction supportsInterface(bytes4 interfaceId)\\n    public\\n    view\\n    override(ERC721, ERC721Enumerable)\\n    returns (bool)\\n{\\n    return super.supportsInterface(interfaceId);\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 3\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Implement Minting Function.\"), \"\\nCreate a function to mint new NFTs.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function mint(address to, uint256 tokenId) public {\\n    _safeMint(to, tokenId);\\n    // Additional logic can be added here\\n}\\n\")), mdx(\"ol\", {\n    \"start\": 4\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Accessing Enumerable Features\"), \" (refer \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Enumerable\"\n  }, \"Open Zeppelin Docs\"), \" to know more).\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use totalSupply() to get the total number of tokens minted.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tokenByIndex(uint256 index) to access a token by its global index.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tokenOfOwnerByIndex(address owner, uint256 index) to find a user\\u2019s token by index.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function getTokenByIndex(uint256 index) public view returns (uint256) {\\n    return tokenByIndex(index);\\n}\\n\\nfunction getTokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n    return tokenOfOwnerByIndex(owner, index);\\n}\\n\")), mdx(\"p\", null, \"This basic structure covers the essentials of using ERC721 Enumerable in a smart contract. With this, you can easily get the totalSupply of an NFT collection, fetch any token by its index or fetch tokens held by an owner.\"), mdx(\"h2\", null, \"Understanding the Underlying Mechanics\"), mdx(\"p\", null, \"We have discussed a bit about the uses of ERC721 Enumerable and how we can use it to create an NFT contract. Now, let us dive deep into it and see how and why it is useful, in what ways and how is it better than other approaches which can give the same result to get totalSupply, fetching tokens by index or owner.\"), mdx(\"p\", null, \"To answer the simple question of \\u201D\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"why?\"), \"\\u201D with a simple answer: \"), mdx(\"u\", null, \"ERC721 Enumerable is designed for efficiency and reduced gas costs, crucial in Ethereum transactions.\"), mdx(\"p\", null, \"We know that you are curious to know the detailed explanation too. Here it is.\"), mdx(\"h3\", null, \"Usage of additional data structures and storage\"), mdx(\"p\", null, \"We refer to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol\"\n  }, \"ERC721\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol\"\n  }, \"ERC721 Enumerable\"), \" by Open Zeppelin for this.\"), mdx(\"h4\", null, \"ERC721\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"abstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    mapping(uint256 tokenId => address) private _owners;\\n\\n    mapping(address owner => uint256) private _balances;\\n\")), mdx(\"h4\", null, \"ERC721 Enumerable\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    mapping(address owner => mapping(uint256 index => uint256)) private _ownedTokens;\\n    mapping(uint256 tokenId => uint256) private _ownedTokensIndex;\\n\\n    uint256[] private _allTokens;\\n    mapping(uint256 tokenId => uint256) private _allTokensIndex;\\n\")), mdx(\"h4\", null, \"Going into the details\"), mdx(\"p\", null, \"If you observe here, the Enumerable version has 4 extra storage variables i.e., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_ownedTokens\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_ownedTokensIndex\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_allTokens\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_allTokensIndex\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_ownedTokens\"), \": Maps an owner\\u2019s address to their owned token IDs.\\nExample: If Alice (address \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1234...alice\"), \") owns tokens 1, 2, and 5, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_ownedTokens[0x1234...alice]\"), \" could return \", \"[1, 2, 5]\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_ownedTokensIndex\"), \": Maps a token ID to its index in the owner\\u2019s tokens list.\\nExample: If Alice\\u2019s 3rd token ID is 5, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_ownedTokensIndex[5]\"), \" returns 2 (the index of token 5 in Alice\\u2019s list in the example above).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens\"), \": An array of all token IDs in the contract.\\nExample: If there are three minted tokens with IDs 1, 2, and 5, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens\"), \" could be \", \"[1, 2, 5]\", \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokensIndex\"), \": Maps each token ID to its index in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens\"), \".\\nExample: Token ID 2 is the second token in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens\"), \" (from the example above), \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokensIndex[2]\"), \" returns 1.\")), mdx(\"h3\", null, \"What makes the Enumerable different\"), mdx(\"p\", null, \"These 4 storage variables are the reason why ERC721 Enumerable is gas-efficient, optimal for tracking and management of tokens owned by addresses.\"), mdx(\"p\", null, \"For example, \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To get the total supply, you just have to return the length of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To retrieve the token data by an index we can simply use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_allTokens[index]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"To get a single token owned by an owner we can simply use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"_ownedTokens[owner][index]\"))), mdx(\"h3\", null, \"How are storage variables useful and how do they affect?\"), mdx(\"p\", null, \"Imagine you want to know the number of tokens that have been minted so far in ERC721. We have to go through all key-value pairs in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_owners\"), \" mapping or calculate the sum of all values in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"_balances\"), \" mapping.\"), mdx(\"p\", null, \"But, the catch here is we cannot simply iterate over them, we must get all the keys or values (\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"for which you have to maintain another storage variable, as Solidity doesn\\u2019t have an implementation to get all keys/values from a mapping\"), \") and do the necessary sum operations to get the total supply which is very high in gas cost. So in short this is \", mdx(\"u\", null, \"quite inefficient\"), \".\"), mdx(\"p\", null, \"On the other side having an extra storage variable which alters the state of the blockchain would cost you some gas on writes and reads but at least they are far lesser when compared to the earlier approach.\"), mdx(\"h3\", null, \"Alternative Storage Considerations\"), mdx(\"h4\", null, \"Storing an Array of Tokens Per Address:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"mapping (address owner => uint[]) private ownerTokens;\\n\")), mdx(\"p\", null, \"This approach would significantly increase gas costs due to high storage requirements and reads/writes on array change with the number of elements in an array.\"), mdx(\"p\", null, \"As the number of tokens owned by the owner increases it will increase the gas cost.\"), mdx(\"p\", null, \"Also when setting the token IDs in an array, we must either define a fixed-length array or use a dynamic-length array. This again has a problem for each approach.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"fixed-length\"), \" - you have to specify the number of max tokens held by an address and it will take up storage space to store max number of token IDs in the array even if the address only owns 1 token. Waste of storage. Also, you must decide on the number of max tokens an address could hold or choose a high number so that we never reach the overflow point. \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"Which by the way is not a good idea\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"dynamic-length\"), \" - you have to always adjust the size of the array and add/remove token IDs which is not gas efficient when compared to mapping read/write operations\")), mdx(\"h4\", null, \"Returning a List of Owned Tokens:\"), mdx(\"p\", null, \"Directly returning a list is not gas-efficient.\"), mdx(\"p\", null, \"It again needs an extra storage variable to support us to iterate over all the tokens held by an address.\"), mdx(\"p\", null, \"Consider an example where the dApp wants to show details of a single NFT owned by an address, they might have to get a list of all tokens and iterate over them in frontend to pick one token and display its data. Here we are sending data that is unnecessary, also this affects gas costs drastically as the number of tokens owned increases for an address. Because it would take more memory and more unnecessary processing power on the node.\"), mdx(\"h3\", null, \"Compare and Contrast\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ERC721 Enumerable Approach\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Other Approaches\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Use of multiple extra mapping storage.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Use of single extra array storage.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Reads/writes have almost constant gas costs.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Gas cost increases with the array sizes.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Has granularity to get data for a single token with constant gas cost.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Have to iterate and pick the token, which varies the gas cost.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Easy for tracking.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Need extra processing and would need more storage variables to do so.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Not easy to iterate over all tokens of the owner by using single storage.\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Can easily iterate over tokens owned by an address.\")))), mdx(\"h3\", null, \"Should we go for readability over efficiency?\"), mdx(\"p\", null, \"It completely depends on the particular use of the contract, how the reads and writes are done, what is the frequency of each operation, the purpose of the NFT contract and various other things.\"), mdx(\"p\", null, \"But when we look at the ease of implementation, efficiency and usability, ERC721 Enumerable has figured out most of them and solves most of the issues. Unless the project has \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"some specific and sophisticated requirements which get benefit from the use of arrays\"), \" for the storage of tokens for an address, \", mdx(\"u\", null, \"ERC721ERC721 Enumerable should do the job in most cases\"), \".\"), mdx(\"h3\", null, \"Projects Utilizing ERC721 Enumerable\"), mdx(\"p\", null, \"Many NFT projects leverage ERC721 Enumerable to manage large collections efficiently, ensuring users can quickly access ownership data.\"), mdx(\"p\", null, \"Some popular NFT project examples are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#code\"\n  }, \"Bored Ape Yacht Club\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://etherscan.io/token/0xed5af388653567af2f388e6224dc7c4b3241c544\"\n  }, \"Azuki\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://etherscan.io/token/0xb119ec7ee48928a94789ed0842309faf34f0c790#code\"\n  }, \"Lawless\"))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"You can go through the verified code of the above contracts to see how they made use of ERC721Enumerable\")), mdx(\"h2\", null, \"Problems Solved\"), mdx(\"p\", null, \"ERC721 Enumerable addresses the challenge of efficiently tracking and enumerating NFTs in a collection, particularly vital for projects with extensive NFT assets.\"), mdx(\"h2\", null, \"Potential Issues and Considerations\"), mdx(\"p\", null, \"The ERC721 Enumerable extension, while useful, introduces some potential security concerns and issues:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Gas Costs\"), \": Functions that iterate over large data sets can incur significant gas costs, potentially making the contract expensive to interact with.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Denial of Service (DoS) Vulnerabilities\"), \": Malicious actors could exploit high gas costs in enumeration functions to cause DoS attacks, especially in functions like tokenOfOwnerByIndex when called with a high index value.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Complexity and Bugs\"), \": Additional complexity introduced by enumerable functionality can lead to bugs, making the contract more vulnerable to exploits.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Front-Running Attacks\"), \": Enumeration could expose data that might be susceptible to front-running attacks, where a malicious user observes a transaction and tries to get their own transaction mined first.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Scalability Issues\"), \": As the NFT collection grows, the cost and time of enumeration might increase, which could lead to performance issues.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\"), \": Imagine someone holds a large number of tokens in a collection and getting all of them in a single go would cost more gas \", \"[1]\", \". Sometimes it may cross the block limit \", \"[2]\", \". This makes the whole project sesceptible for more failure of transactions for a use case with large dataset, causing the issues in scaling the project \", \"[5]\", \". This can be considered as a drawback due to the openness and transperency provided by the blockchain. Also due to this a front-runner attacker who might know about rare \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokenId\"), \"s can look into mempool and frontrun to get those NFTs as we store \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tokenId\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index\"), \" in storage while miniting \", \"[4]\", \". With additional data structures there is always a risk for bugs in implementation \", \"[3]\", \".\"), mdx(\"p\", null, \"Though these all can be mitigated too:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"DoS\"), \" can be mitigated by limiting the data being sent for each transaction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Bugs\"), \" can be avoided by proper testing and auditing, running the contract in testnets before putting it on mainnet.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Scalability\"), \" by proper consideration of project details and relying on off chain data, using oracles for that data. Also to try making it more modular.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Front-running\"), \" is always an issue but one can consider commit-reveal schemes, time lock for addresses, increase in randomness, not disclosing the raribility of tokens before minting.\")), mdx(\"p\", null, \"All the issues are quite common in most of the smart contracts. We always got to tackle them anyway :wink:.\"), mdx(\"h2\", null, \"Use Cases\"), mdx(\"p\", null, \"ERC721 Enumerable is ideal for projects \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that require efficient enumeration of NFTs, such as marketplaces or galleries.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that need to fetch data for single token by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tokenID\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"owner\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that has an NFT collection where minting is random and tracking them is essential\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The job of NFT marketplaces like OpenSea and Rarible would be very tough and they might had to go for a centralised API to keep track of NFTs if ERC721Enumerable doesn\\u2019t exist\")), mdx(\"h3\", null, \"Key Considerations for Users\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Understand Gas Implications\"), \": Be aware of the gas costs associated with large-scale enumeration.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scalability Planning\"), \": Plan for potential scalability challenges as your NFT collection grows.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"ERC721 Enumerable extends the basic ERC721 functionality to efficiently track and enumerate tokens. It balances the need for detailed information with the practical considerations of gas costs and blockchain efficiency. Understanding its use and underlying structure is crucial for developing robust and efficient NFT projects.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":["3572198028","3765610985"]}