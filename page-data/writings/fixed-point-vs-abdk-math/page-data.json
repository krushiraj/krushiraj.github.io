{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/writings/fixed-point-vs-abdk-math/","result":{"data":{"mdx":{"id":"699e1eb4-6edb-5a69-a23a-30ad7d87e8da","parent":{"sourceInstanceName":"content"},"excerpt":"FixedPointMathLib vs ABDKMath64x64 - What should you use? In Solidity we don't have  Fixed Point Arithmetic  out-of-the-box, hence we relyâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"FixedPointMathLib vs ABDKMath64x64 - What should you use?\",\n  \"date\": \"2023-12-23\",\n  \"type\": \"article\",\n  \"published\": true,\n  \"keywords\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"description\": \"An article about which library to pick for fractional arithmetic in Solidity.\",\n  \"tags\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"banner\": \"./comparison.jpeg\",\n  \"bannercaption\": \"Image from Google Images\",\n  \"technologies\": \"solidity,web3\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"FixedPointMathLib vs ABDKMath64x64 - What should you use?\"), mdx(\"p\", null, \"In Solidity we don\\u2019t have \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Fixed Point Arithmetic\"), \" out-of-the-box, hence we rely on various libraries to make it easier and safer for us. \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\"\n  }, \"FixedPointMathLib\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\"\n  }, \"ABDKMath64x64\"), \" are some of the well known libraries that handle this.\"), mdx(\"p\", null, \"Lets see which one should you be using and why? There can be a lot of factor to support the decision of which one to use, we will go through a couple of things that matter and see which one has to be used based on the scenario that a smart contract developer has.\"), mdx(\"h2\", null, \"Differences\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Precision and Range\"), \":    \"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Operates with a 64.64 fixed point math library, meaning it uses 64 bits for the integer part and 64 bits for the fractional part. This allows for high precision and a wide range of numbers, but it can be more computationally intensive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": This library uses a different approach and have a different precision range with WAD factor which is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10**18\"), \".\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Performance\"), \":\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Known for high precision, but this can come at the cost of gas (when used in Ethereum smart contracts), as operations are more complex and you might have to keep converting the numbers from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"int\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"64x64\"), \" format.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": Less gas-intensive for certain operations as it relies on the Yul to make use of direct math functions mostly.\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Use Cases\"), \":    \"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ABDKMath64x64\"), \": Its high precision makes it suitable for financial applications, complex calculations, and anywhere that a very small margin of error is critical.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"FixedPointMathLib\"), \": Good to use when we have simple calculations that can be done with in 18 decimal point precision. Most of the transactions of ERC20 and user facing data will be similar to this. So better for naive usage.\")))), mdx(\"h2\", null, \"Code in action\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"// SPDX-License-Identifier: MIT\\npragma  solidity  >=0.8.0;\\n\\nimport  \\\"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport  \\\"https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol\\\";\\n\\nusing FixedPointMathLib for  uint256;\\nusing FixedPointMathLib for  int256;\\n\\nusing ABDKMath64x64 for  int128;\\n\\ncontract Math {\\n    function mul0(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        c = a * b;\\n    }\\n    \\n    function mul1(int128 a,  int128 b)  public  pure  returns  (int128 c)  {\\n        c = a.mul(b);\\n    }\\n    \\n    function mul2(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        int128 aFixed = ABDKMath64x64.fromUInt(a);\\n        int128 bFixed = ABDKMath64x64.fromUInt(b);\\n\\n        // Perform the calculation using ABDKMath64x64\\n        int128 rawResult = aFixed.mul(bFixed);\\n        \\n        // Convert the result back to uint for the return value\\n        c = ABDKMath64x64.toUInt(rawResult);\\n    }\\n\\n    function mul3(uint256 a,  uint256 b)  public  pure  returns  (uint256 c)  {\\n        c = a.mulWad(b);\\n    }\\n\\n    function pow0(int256 a,  int256 b)  public  pure  returns  (int256 c)  {\\n        c = a.powWad(b);\\n    }\\n\\n    function pow1(int128 a,  uint256 b)  internal  pure  returns  (int128 c)  {\\n        c = a.pow(b);\\n    }\\n}\\n\")), mdx(\"p\", null, \"This smart contract tries to make use of both the libraries to do some basic multiplication and then calculate power.\"), mdx(\"p\", null, \"Now we will try to execute each of those and see how each performs. We only care about inputs, outputs and gas here. So rest of logs are omitted here.\"), mdx(\"h3\", null, \"mul0\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to: Math.mul0(uint256,uint256)\\n\\nexecution cost\\n1049 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120\\\", \\\"uint256 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600\\\" }[]\\n\")), mdx(\"p\", null, \"This is direct multiplication in solidity without any help of libraries. Simple to understand inputs and output.\"), mdx(\"h3\", null, \"mul1\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul1(int128,int128) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1058 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int128 a\\\": \\\"120\\\", \\\"int128 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int128: c 0\\\" }[]\\n\")), mdx(\"p\", null, \"The output here is 0. Any idea about why is that 0?\\nIt is because the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" library expects the number to be in the form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\"), \" bit representation. That means we need to convert the number to binary and then add 64 bit of binary 0 to make fractional part 0 for that number. Lets do that for 120 and 130\\n| decimal | binary (without 64 zeros for fractional part) | decimal for 64.64 |\\n|----------|---------|------------------|\\n|120 | 1111000 | 2213609288845146193920 |\\n|130 | 10000010 | 2398076729582241710080 |\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul1(int128,int128) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1058 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int128 a\\\": \\\"2213609288845146193920\\\", \\\"int128 b\\\": \\\"2398076729582241710080\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int128: c 287769207549869005209600\\\" }[]\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"287769207549869005209600 = 111100111100000000000000000000000000000000000000000000000000000000000000000000 = 15600\")), mdx(\"h3\", null, \"mul2\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"Math.mul2(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n1351 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120\\\", \\\"uint256 b\\\": \\\"130\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600\\\" }[]\\n\")), mdx(\"p\", null, \"This is using \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \", but the catch here is we used extra helpers to convert instead of doing it all by ourselves like we did before. Hence extra gas cost.\"), mdx(\"h3\", null, \"mul3\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul3(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n877 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"128\\\", \\\"uint256 b\\\": \\\"128\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 0\\\" }[]\\n\")), mdx(\"p\", null, \"The same again, not the results we wanted to see. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \" expects a number with 18 decimal places i.e., we need to append 18 zeros after the number\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.mul3(uint256,uint256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n877 gas (Cost only applies when called by a contract)[]\\n\\n\\ndecoded input\\n{ \\\"uint256 a\\\": \\\"120000000000000000000\\\", \\\"uint256 b\\\": \\\"130000000000000000000\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"uint256: c 15600000000000000000000\\\" }[]\\n\")), mdx(\"p\", null, \"Now we get the correct output but with 18 zeros appended to it.\"), mdx(\"h3\", null, \"pow0\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.pow0(int256,int256) 0x9D7f74d0C41E726EC95884E0e97Fa6129e3b5E99[]\\n\\nexecution cost\\n2723 gas (Cost only applies when called by a contract)[]\\n\\ndecoded input\\n{ \\\"int256 a\\\": \\\"2000000000000000000\\\", \\\"int256 b\\\": \\\"10000000000000000000\\\" }[]\\n\\ndecoded output\\n{ \\\"0\\\": \\\"int256: c 1023999999999999995727\\\" }[]\\n\")), mdx(\"p\", null, \"Uses the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \". I would expect \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2 ** 10\"), \" to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1024\"), \". But the value here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1023.999.....5727\"), \" which is not correct but close when we round up.\"), mdx(\"h3\", null, \"pow1\"), mdx(\"p\", null, \"Users the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \". For conversion\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \" - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \" in binary and when converted to int with 64 bit decimal places, it is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"18446744073709551616\"), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10\"), \" - we give this directly as the power is expected in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int128\"), \" but not \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"to\\n\\nMath.pow1(int128,uint256) 0xddaAd340b0f1Ef65169Ae5E41A8b10776a75482d[](https://remix.ethereum.org/#)\\n\\nexecution cost\\n\\n2302 gas (Cost only applies when called by a contract)[](https://remix.ethereum.org/#)\\n\\ninput\\n\\n0x9ea...0000a[](https://remix.ethereum.org/#)\\n\\ndecoded input\\n\\n{ \\\"int128 a\\\": \\\"36893488147419103232\\\", \\\"uint256 b\\\": \\\"10\\\" }[](https://remix.ethereum.org/#)\\n\\ndecoded output\\n\\n{ \\\"0\\\": \\\"int128: c 18889465931478580854784\\\" }[](https://remix.ethereum.org/#)\\n\")), mdx(\"p\", null, \"The output when converted to binary will give us \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10000000000+64 zeros\"), \". Those 64 zeros can be omitted to get the integral part which then converts to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1024\"), \", the exact output for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2 ** 10\")), mdx(\"h3\", null, \"Gas costs\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"ABDKMath64x64\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"FixedPointMathLib\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"mul\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1058\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"877\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"pow\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2302\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2723\")))), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If we include gas to convert for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" it would add around 300\")), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \" is gas efficient for complex calculations and very precise and accurate for smaller integral numbers with large fractional part.\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \" is good with large numbers and has less precision for more complex calculations, but highly gas efficient for basic math.\"), mdx(\"p\", null, \"So, if you are building something that include complex formulae like bonding curve, exponential farming or anything that requires high precision and complex calculations one should go for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ABDKMath64x64\"), \", else if you require basic math with low precision which is mostly used in transfer, ERC20 related, more user facing applications and functions one should go for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"FixedPointMathLib\"), \", as for user facing you don\\u2019t have to put in extra effort to convert it to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"64.64\"), \"format when compared to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WAD\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"FixedPointMathLib vs ABDKMath64x64 - What should you use?","date":"December 23, 2023","description":"An article about which library to pick for fractional arithmetic in Solidity.","technologies":"solidity,web3","tags":"web3,math,arithmetic,fixedpoint,solidity","keywords":"web3,math,arithmetic,fixedpoint,solidity","banner":{"childImageSharp":{"fluid":{"tracedSVG":"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='400'%20height='400'%20viewBox='0%200%20400%20400'%20preserveAspectRatio='none'%3e%3cpath%20d='m201%208-5%2011-1%203h4c5%200%205%200%205%203l-1%202-1%202-154%201H16v40a138067%20138067%200%200%201%200%20282v19h14c12%200%2013%200%2013%202l1%202%201-2c0-2%201-2%2015-2s15%200%2015%202l1%202%201-2c0-2%201-2%2015-2s15%200%2015%202l1%202%201-2c0-2%201-2%2014-2s14%200%2014%202l1%202%201-2c0-2%201-2%2016-2%2014%200%2015%200%2015%202l1%202%201-2c1-2%202-2%2016-2h16v3c0%202%200%202-3%202h-3l2%203%202%204%201%201%201%203c1%203%204%203%205%200l1-3%204-7-3-1c-2%200-3-1-3-3v-2h20c18%200%2019%200%2020%202l1%202%201-2c0-2%201-2%2013-2s13%200%2013%202l1%202%201-2c0-2%201-2%2014-2s14%200%2014%202l1%202%201-2c0-2%201-2%2015-2%2013%200%2014%200%2014%202l1%202%201-2c0-2%201-2%2015-2%2013%200%2014%201%2014%202l1%202%201-2c0-2%201-2%2015-2s15%200%2015-2c1-11%200-24-2-25h-2l-1-1-1-1-12-7c-10-6-11-6-9-8%201-2%201-2-1-4l-2-3%202-1%203-3c1-2%204-1%205%201%202%203%205%201%203-2-1-2%201-6%205-8l2-2c-1-1%203-4%204-3l1-2%202-3c3-1%204-8%203-11v-6c0-3%200-4-2-4v-5c2-2%203-21%202-23l-1%201c0%201-1%201-2-1-2-2-2-3%200-1%201%201%202%201%202-1v-2c-3-1-3-15-1-17l2-8v-6%202l-1%201-2-2-1-2-1-2%201-3c2-1%201-5-1-5-1-1-1%200-2%201-1%203-1%203-8%203-9%200-9%200-6-6l2-6%203-10%201-2%202-4%202-7%204-15%203-11c-1-3-4-1-4%203l-4%207c-2%202-3%204-2%205l-1%201-2%202-1%201-1%202-1%202c-1-1-1%200-1%201s0%202-1%201l-1%201v3l-4%208-1%202-1%202-1%201-1%202-3%204c-3%203-3%203-12%203-6-1-10-1-12-3l-3-1%202-1c4%200%204-1%204-8%201-4%201-6%203-8s2-5%200-5l-1-1%201-1h2a2218%202218%200%200%200%2010-10l5-7%202-4%202-2v-17l-1%203-2%205-2%202c0%202-4%206-6%206l-2%202-2%202-3%202c-3%203-5%200-5-13%200-12-3-14-3-3l-1%206-1%202-1%202c-2-1-2-12-1-12l1-2v-2c1-1%201-1-1-1-1%200-2%200-1%202l-1%202-1%202v1h-1l1%202%201%201-1%201c-1-1-1%200-1%203l-2%201h-1v2l-1-7c-1-6-3-11-3-6l-1%202-1%205c0%205-1%206-7%208-3%202-4%202-5%200v-7a203%20203%200%200%200%200-41l-1-8v-6c-1%200-2%201-1%203l-1%202-1-2v-2l-2-1c-1%200-1%204%201%2019v9c-1%201-1%200-1-5%200-10-2-13-4-6-1%205-2%206-7%206-6%200-6%201-6-6l-2-9v-4l-1-1-1-2-4-2c-2%200-3%201-1%207s2%2021%201%2021l-2-1c-1-11-2-13-4-13l-1%208v9h-3c1-7-2-11-3-4l-1%204-1%203c0%203%200%205-2%206l-2%203-2%207-1%202-2%204c-3%207-4%203-4-15%200-14%200-16-2-17s-2%200-3%2011l-1%206-4-22-1-6-3-9-1%2021v25l-1%203-2-4-8-22c-3-10-2-18%205-35l-1-1c-1%200-3%203-4%207l-3%207V73c1-18-1-19-3-2-2%2013-2%2013-5-2l-1-12v-1l-2-9-3-12c0-2%200-2%208-2a158%20158%200%200%201%2035%201l73-1c62%200%2072%200%2072-2%201-1-11-1-94-1h-96l-1-4v-4h9L206%200l-5%208M53%2033H19v7c0%206%200%207%202%207v1c-3%200-3%208%200%208l3%201h-5v43c0%2041%200%2044%202%2044v1c-2%200-2%203-2%2052a4785%204785%200%200%200%204%20142l5-4c3-1%205-3%2014-11l17-15%209-9-1-5c0-3-1-5-2-5l-1%201v6l-2-3-4-2c-2%201-2%201-1-1l-2-1h-3l1-1-1-2c-1-1-3-2-4-1l-1-2v-2h-3c-1%201-1%201-1-1v-3c-2%201-3-1-2-4l-9-1c-2%200-3%200-3-2h-1c-1%201-1%200-1-2l-4-4c-3-3-3-3-3-8l1-6%203-3c0-2%200-3%201-2h2l3-1c1-2%202-3%201-4s-1-1%201-1%202%200%202%202v1l1-11c1-7%200-10-3-10l-3-2-2-1-3-3%201-1v-5c-1-8%200-14%202-14l2-2c0-4%201%201%202%206%200%2010%203%209%204-2%201-4%201-5%203-4h3v7l-1%204c0%204%201%205%202%204l1-8c0-7%200-8%201-7l3%203c1%203%201%203%201%201%200-4%203-2%204%202l2%207%201%207c0%207%201%207%207%202%203-3%203-4%202-8l1-5%201-3-1-4v-5l-1-5-1-2-2-2c-1-1-1-1%201-1s2%200%201-3v-13c0-2%200-2%201-1s1%201%201-2v-4l1-1%202-2c2%200%202%200%202%205-1%205-1%205%201%205l3-2%201-1%201-2c0-2%200-2%202%201l2%204%201-1%201-1c3%200%205-3%205-5s0-3%202-3l3-2%202-1%201-2%206-6c2-1%203-5%201-5l-4%202h-6c-5-3-6-7-2-7%202-1%202-1%200-2-4-2-3-6%201-10%202-3%203-4%203-8l1-4%201-6%201-7%201%209v10l5-1a620%20620%200%200%200%206-2c0-2%200-3%202-3l1%203c-1%201%200%202%201%202l1-1h2c2%201%202%201%202-9l1-9c1%201%202%203%202%208l1%207%201%202%201%201%201%205%201%205%201%202c0%204%202%206%204%206%201-1%202%200%202%202%201%203%201%203%202%202s1-1%201%201l-1%202v1l2-1%202-1%201-2c0-2%200-2-1%200-1%201-1%201-1-2l-1-4c-1-2-5-2-5-1l-2%201v-1l1-1v-8l1%203c0%203%205%206%205%203l-2-1c-2%200-2-1-2-4%200-2%200-3-1-2l-1-1%202-1v-1l-1-2%203%201v3l-1%202%201%202h2l-1%201-2%201h2l2%201%202%203v5c1%200%202%205%201%206v1l2%201h-3c-1-1-1-1-1%201l2%202%202-1c0-2%202%201%203%203v3l1%206%201%203%201-7v-25l1-19c1-2%202-1%202%204l3%2014v4l1%202%201-4v-9c1-12%201-13%202-12h1l1-1%202%2016c0%203%200%203%201%202l1-5c0-3%200-4%201-3l1-3%201-9%201-3%202-13%203%201v1l1%203v-1l1-2v3c0%201%200%202%201%201s2%200%204%204l2%202h1l1%201%201-2h-1v-1c1-2%201-2-1-2v-1l1-1h-2l-1-1v-1h-1l2-1c1%201%201-3-1-8-2-4-3-9-2-9s2%202%203%207l1%203c2%205%202%202%202-12l1-13%204%2017%201%202a262%20262%200%200%200%204-29v-1c2%200%202-1%203-7l2-5c0-2%200-2-8-2h-9a7101%207101%200%200%201-131%200m118%2081c1%2017%201%2020%203%2020l6-15%201-4%201-4%201-5c2-1%200-2-3-1-2%200-2%200-1-1h-1l-2-1%202-1v-1l-2-1%202-2c1-1%201-1-1-1l-2%202-2-1c-2-2-2-2-2%2016m122%2056%202%205%201%204%205%208c1%201%201%201-1%201l-2%201c0%201%205%204%207%203l1%201%201%202%201-1h1l1-2c1-4%200-7-1-8l-2-7c-1-5-1-6-1-2v5l-3%201c-4-1-8-7-8-12l-2-2v3m-178%208c0%202%200%202-1%201l-3-2c-2%201-3%204-1%204%201%201%201%201-1%201-1%200-2%200-1-2h-3l-1%201h-1c-2%202-3%201-3-1-1-2-1-2-1%200l-1%203c-1%201-1%201%201%201l-1%201c-2%200-2%201-2%204l1%204c1%202%205%201%206-1%201-1%201-1%201%201s-1%202-2%202l-2%201c-1%201%200%201%203%201l4-1%202-2c1-1%202%201%200%202l-1%202c0%202%200%202%201%201%200-1%201-3%203-3l2-4c0-2%200-2-1-1-2%203-3%202-2-1%200-2%200-2-1%200l-1%201-2-1v2l-1%202c-2-2-2-5%200-5l2-1h1l1-2%201-2%203-1%203-2%202-2h-1c0%202-2%201-1-1l-1-2-1%202m184%2037c-1%201%202%203%203%203h2l4%201h3v2c-1%200%201%202%206%204l9%206%202%201c0-2-3-6-5-6l-1-1h-1l-1-1c1-2-3-5-5-5s-3-1-3-3c-1-2-1-2-2-1h-1c0-1-10-2-10%200m-230%206c-3%200-3%200-3%206-1%206%200%2010%201%206%201-1%201-1%201%201l-1%202-2%201%202%201c2%200%202-1%202-7l1-8-1%2017v2c-1%200-2%201-1%202l-1%203v3c3%200%204-6%205-18v-12l-3%201m199%202-5%201c-4%200-5%201-5%207%200%202%200%203-1%202%200-3-2-5-2-3h-1c-1-1-1-1-1%201l-1%206c-2%201%200%204%202%203%202%200%202%200%201%201l1%202%201-4c-1-1%200-1%201-1%202%200%202%200%201%202v2c-1%201-2%205%200%204l1%201c0%202%204%200%209-3%203-2%204-3%203-4s-1-1%201-1l4-4c2-3%202-5%200-3l-2%202c-2%200-5%203-4%204l-1%201c-1-1-1-1%200%200l-1%202v1l-1%201-3%201c-2%202-4%201-2-2%201-1%201-2-1-3-2-2-3-3-1-3%201%201%202%200%202-1%201-1%201%200%201%202%200%203%202%204%202%202l1-5c1-4%201-4-1-4l-3%202-2%202v-2l1-4c0-2%200-2%201%200h1l3-3%203-2h-2m-228%204a361%20361%200%200%200%201%2021c2%201%203%202%203%207l1%205%201-8v-8c2-1%200-13-2-15l-4-2m105%204-1%206c0%204%200%205%201%203s1-2%201%200l1%202h3l4-1c2%201%203-2%201-5l-1%201-1%203v-3l-1-5-2-1h-5m136%203v2l-2%202v3l-3%201h3l2%201c-1%201%200%201%201%201%202%200%202%200%200%201s-4%202-5%201c-2-1-4%201-2%202l5%206c4%205%204%205%209%205l10%201c5%200%205%200%204-2a171%20171%200%200%201-12-15l-1-1-6-8h-3m35%203c3%202%205%206%206%208l2%203%201%204c0%202%201%203%203%202%203-2%201-15-2-15l-1-1c1-2-5-5-9-5h-3l3%204m-166%209c0%202-1%202-3%202s-1%202%200%202c1%201%201%201-1%201s-3%202-2%203c1%202%202%201%201-1h1c2%202%202%202%202%200s1-1%201%202c1%203%202%205%204%205l1%201%201%201%203%201c4%200%205-1%205-5%200-3-1-5-3-4l1%202v1l-1%202-1%202v-4c0-3%200-3-3-3-4%201-5%200-3-3%201-2%202-3%201-4v-1l-1-1c-2-1-2%200-3%201m100%203c-2%201-2%201-1%202v1c-2%200-2%200-1%201h3l-1%202-1%203-1%203c-1%201%200%201%201%201%202%200%202%200%201%201-2%200-4%207-3%2011%200%202%200%202%202-1l3-3%204-5-1%202v2l-1%201v1c2%202%208-7%207-10v-3l-2%203-3%203-3-2c-2-1-2-1%200-1l2-1%202-1%201-1c-1-1%200-3%202-4%203-2%204-6%201-5l-2%201-1%202v3l-1-3c0-2%200-2-3%200h-2v-2c0-2%200-2-2-1m-143%209c1%202%200%203-1%202h-1c0%203%200%204-2%204l-2-1-1-2v2c-2-1-5%203-4%205v1l-1-1-2%201-2%203-1%201c-1-1-1%200-1%204s0%204%201%201%201-3%201-1%200%202%201%201l4-5%201-3%201-1%203-1%202-1%202-2%203-2%203-2-1-1-1-1-1-2-1%201m131%200-1%205-1%207c-2%202-2%206%200%206h1l-1%201v2h-1c-1-1-1-1-1%201-1%202-1%202-2%201h-2c-2%201-3%2011-1%2010l2%204%202%205-1-5c-1-3-2-9%200-6h2l1%201-1%201c-1-1-1%200-1%201%200%203%201%205%203%204l1%202c0%203%202%208%209%2019%202%204%203%204%202-1l1-5%201%205%202%204%201%201c-1%201%200%202%202%203%202%202%202%202%202%200s1-1%202%202c2%206%205%2010%207%209v1l-1%201h4l-1-3-3-1c-1%200-2%200-1-1%202-1-2-12-4-12l-1-1-1-6-3-5-1-4-1%203v2l-2-7c0-6%200-7-1-4l-1%203v-3c-2-8-3-10-4-9s-1%201-1-1v-2l-1-1-1-3-1-5c0-2%200-2-1-1-2%202-1%203%201%208%202%206%203%208%201%206l-1-2h-1l-1%202v2h2c0%204-2%203-4-1-3-6-4-7-5-6s-1%201-1-1%200-2%202-1l2%202h1c1-2%201-2%201%200l2%203-1-5v-6c2-4%202-22%200-19m-113%2029-5%201-3%202-5%201c-6%201-7%201-9%206l-2%202c0-2-2-1-3%201-1%204%204%205%206%202l2-3v-1c-1-1-1-1%201-1%201%201%202%200%203-1%203-4%2020-7%2018-3l-5%201-6%201-2%201-4%202-2%202h10l-6%201c-5%200-7%201-7%202%200%203%209%203%2011%200h2c0%202-3%204-7%203l-6%201c-2%201-2%201%200%201s4%203%202%203l-1-1-2-1c-2%200-2%200-2%202v1l-1%201h1l4-1c3%200%204-1%204-3l2-1c2%200%202%200%201%201-3%202-2%203%201%203s7-4%207-6h1c1%202%207-4%207-7l-2-1c-1%200-3-2-1-2h2l1-1%201-2%201%203v2c0-2%201-2%201-1%200%202%203%201%203%200l1-2c1%201%204-3%203-4l-4%201c-4%201-5%200-1-1%203-1%204-5%202-5v2l-1%201v-1l-1-1-3%201-1%202-1%201v-4c0-2-1-3-5%200m142%208-2%202h2l2%204c0%202%200%202-1%200s-1-2-1%201v4l-1-4c-1-3-1-3-1%202%200%204%200%205%203%208s3%203%204%202h1l1%202h4l-1-1-2-1-1-2-1-2c-1-1-1-1-1%201s0%202-1%201v-13h1l2-2%201%202h1l1-2v4l2%201%201%201v1l2%202h4l2%201%202%201%201-2v-1c-2%200-1-3%201-3h1l1%201c1-1%203%203%203%206%200%202%200%202%201%200l2-2v3c-2%202-2%2013-1%2017%203%204%204%203%202-1l-1-7c0-4%200-4%201-1l4%2013-2-17v-2c1-1%201-7-1-7h-1l-2-1-4-4c-1-2-3-3-3%200l-1%201-2%202h-2l-3-2c-1-2-3-3-3-2l-1-1-8-4c-2-1-3%200-5%201m73-1-1%201-1%207c0%205%200%206%202%206l1%201h-1c-2%200-3%202-1%202v2l-1%206%201%206%201-6c0-6%200-6%202-5s4-2%201-5v-1c2%200%201-7-1-9v-2l-1-1v-1l-1-2v1m-66%2012%204%205v1l1%201h4l2%201%201%201h2l1%201h1c1-1%201-1%201%201s0%202%203%200c2-1%203-4%201-6-3-1-4-1-5%201%200%203-1%203-3%200l-3-2-1-1-1-1-3-2-3-1c-1%201-1%201-1-1%201-1%200-3-3-3l2%205m79%204%203%206%204%203%201-2%202-3c0%201%203-1%203-3s-3-4-8-4-5%200-5%203M69%20321c-2%203-3%205-3%209v5l-1-4c0-4-1-4-1-2v5l1%203%203%201c3%200%203%200%203-6l3-10c2-3%201-6-1-3h-1c0-1-2%200-3%202m238%207c0%204%200%206-1%205l-1-1c0%203%201%205%202%204l1%204c-1%206-2%207-3%205h-1c0%202%203%205%203%203h1l2%201%201-1v-2l1%202h7c1%202%202-2%201-5-1-2-1-2-2-1-2%202-5-3-4-7l-1-2-1%205-1%205-1-3-1-6-1-8-1-5v7m-169%205c-1%202-1%202-3%201h-6c-2%200-3%201-1%201s5%204%205%208v1l1-1%201%209c0%205%202%203%202-4%201-6%201-6-1-6l-2-1v-4h1c0-1%201-2%202-1%201%200%202%201%202%203l2%202%201-3c-1-1%200-2%201-3l1-4-1%202-2%202v-2h-2v-2l-1%202'%20fill='%23d3d3d3'%20fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":1,"src":"/static/d457492a2b16548fa23489c88d1e56bb/4fe8c/comparison.jpg","srcSet":"/static/d457492a2b16548fa23489c88d1e56bb/aabdf/comparison.jpg 150w,\n/static/d457492a2b16548fa23489c88d1e56bb/9dc27/comparison.jpg 300w,\n/static/d457492a2b16548fa23489c88d1e56bb/4fe8c/comparison.jpg 600w,\n/static/d457492a2b16548fa23489c88d1e56bb/9842e/comparison.jpg 900w,\n/static/d457492a2b16548fa23489c88d1e56bb/16310/comparison.jpg 1024w","srcWebp":"/static/d457492a2b16548fa23489c88d1e56bb/ad85c/comparison.webp","srcSetWebp":"/static/d457492a2b16548fa23489c88d1e56bb/e7487/comparison.webp 150w,\n/static/d457492a2b16548fa23489c88d1e56bb/403a4/comparison.webp 300w,\n/static/d457492a2b16548fa23489c88d1e56bb/ad85c/comparison.webp 600w,\n/static/d457492a2b16548fa23489c88d1e56bb/210c1/comparison.webp 900w,\n/static/d457492a2b16548fa23489c88d1e56bb/cc834/comparison.webp 1024w","sizes":"(max-width: 600px) 100vw, 600px"}}},"bannercaption":"Image from Google Images"},"fields":{"slug":"/writings/fixed-point-vs-abdk-math/","timeToRead":{"minutes":6.405},"socialImage":{"childImageSharp":{"original":{"width":2400,"height":1254,"src":"/static/13b2d85d5dcd75ba1562a4f082be7f5a-76400bc1bd1655d221bb19214ad32d20.png"}}}}}},"pageContext":{"slug":"/writings/fixed-point-vs-abdk-math/","previous":null,"next":{"parent":{"name":"index","sourceInstanceName":"content"},"fields":{"slug":"/writings/fixed-point-arithmetic-solidity/"},"frontmatter":{"title":"Mastering Fixed Point Arithmetic in Solidity","published":true,"type":"article"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Mastering Fixed Point Arithmetic in Solidity\",\n  \"date\": \"2023-12-23\",\n  \"type\": \"article\",\n  \"published\": true,\n  \"keywords\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"description\": \"An article that explores on why we would need a library to handle fixed point arithmetic in Solidity.\",\n  \"tags\": \"web3,math,arithmetic,fixedpoint,solidity\",\n  \"banner\": \"./fixed-point-arithmetic.png\",\n  \"bannercaption\": \"Image from Google Images\",\n  \"technologies\": \"solidity,web3\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Mastering Fixed Point Arithmetic in Solidity\"), mdx(\"p\", null, \"In the realm of blockchain and smart contract development, efficient and accurate arithmetic operations are crucial. Solidity inherently supports integer arithmetic. However, there are scenarios where we require more precision, and this is where fixed point arithmetic enters the fray. \"), mdx(\"p\", null, \"Fixed point arithmetic allows for fractional calculations, bridging the gap between integer arithmetic\\u2019s limitations and the necessity for precision in certain calculations.\"), mdx(\"p\", null, \"Let\\u2019s delve into the FixedPointMathLib, one of the the libraries that facilitate fixed point arithmetic in Solidity , available on GitHub, source file located \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol\"\n  }, \"here\"), \". To understand its core functionalities and how you can leverage it in your smart contract projects. We\\u2019ll try to understand what \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fixed Point Arithmetic\"), \" is and also go through some code in the library aforementioned.\"), mdx(\"h2\", null, \"Understanding Fixed Point Arithmetic\"), mdx(\"p\", null, \"In fixed point arithmetic, numbers are represented as integers, but a predefined scale factor indicates the decimal point\\u2019s position. For instance, if the scale factor is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"100\"), \", the number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"12345\"), \" represents \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"123.45\"), \". This method allows for fractional computations while utilising integer arithmetic operations, thus maintaining a balance between precision and performance. The scale factor can change depending on our requirement for precision.\"), mdx(\"h2\", null, \"Why even use a Library for this?\"), mdx(\"p\", null, \"If you\\u2019re familiar with other programming languages then you would have already known that most of the languages support floating point and fixed point numbers by default with some data types. For example you can see \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"float\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"double\"), \" types in C/C++. If you can remember we have no such data types in Solidity. That is for a reason, to put it simple it is due to the inconsistencies in the handling and implementation of fractional numbers on machines. Due to these inconsistencies, we might end up in multiple forks of the chain due to minor changes in data on chain.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Need to know more? Your rabbit hole starts \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ethereum.stackexchange.com/a/87235\"\n  }, \"here\"))), mdx(\"h2\", null, \"FixedPointMathLib\"), mdx(\"p\", null, \"Let us look into some functions what this library offers us.\"), mdx(\"h3\", null, \"mulWad\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function is designed to multiply two fixed point numbers. Here\\u2019s the function signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z)\\n\")), mdx(\"p\", null, \"Parameters:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"b\"), \": The fixed point numbers to be multiplied.\")), mdx(\"p\", null, \"If you observe, we have something called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Wad\"), \" in function name. That basically means that the scale factor here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10**18\"), \" (alleged origin of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"wad\"), \" comes from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/dapphub/ds-math/blob/master/README.md\"\n  }, \"here\"), \")\"), mdx(\"p\", null, \"The function employs Yul to perform the multiplication operation efficiently. By leveraging Yul, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function ensures that the multiplication is carried out with a low gas cost, which is crucial for blockchain operations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"/// @solidity memory-safe-assembly\\nassembly {\\n    // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n    if mul(y, gt(x, div(not(0), y))) {\\n        mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\n        revert(0x1c, 0x04)\\n    }\\n    z := div(mul(x, y), WAD)\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" function first computes the product of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" using integer multiplication, then adjusts the result for the scale factor by dividing the product by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"10 ** 18\"), \"(in the file at L51 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WAD\"), \" constant is defined). This way, the function yields the correct fixed point representation of the product.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"if mul(y, gt(x, div(not(0), y)))\\n\")), mdx(\"p\", null, \"If you observe the code checks for the overflow case and makes sure to revert the execution with error.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"not(0)\"), \" - bit wise negation results in the max int value. Ex: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x00\"), \" will be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xFF\"), \" when negated - let us assume this result as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"maxInt\"), \". Here it is actually max value a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"uint256\"), \" can take.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"div(not(0), y))\"), \" - now this will be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"div(maxInt, y)\"), \" - lets assume this as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"quotient\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), y))\"), \" - this will check if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x > quotient\"), \". Simple check to make sure that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x * y < maxInt\"), \". Lets assume this result as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"check\"), \", which can have a value of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD))))))\"), \" - simply means that verifying if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y * check\"), \" is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" or not\")), mdx(\"p\", null, \"This makes it safe to avoid unexpected behaviour of the smart contracts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\\nrevert(0x1c, 0x04)\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mstore(0x00, 0xbac65e5b)\"), \": This line is storing the value \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xbac65e5b\"), \" at memory location \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x00\"), \". The value \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0xbac65e5b\"), \" is likely the hash of the error message \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MulWadFailed()\"), \". Solidity uses the first 4 bytes of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"keccak-256\"), \" hash of the function signature to identify it. This is a common practice to save gas instead of storing the entire string error message.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"revert(0x1c, 0x04)\"), \": This line reverts the transaction. The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"revert\"), \" opcode takes two parameters: the first is the starting position in memory of the data to return, and the second is the size of this data in bytes. In this case, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1c\"), \" is the position in memory where the data starts, and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x04\"), \" is the size of the data to return. It means that when the transaction is reverted, it will return 4 bytes of data starting from the 28th byte (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0x1c\"), \" in hexadecimal) of memory.\")), mdx(\"h3\", null, \"mulWadUp\"), mdx(\"p\", null, \"This is similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \" but the result is rounded up. For the other case it is rounded down\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mod(mul(x, y), WAD))\"), \"- check if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"(x * y) % WAD == 0\"), \"- If it is zero, it means the product is perfectly divisible by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" and there\\u2019s no fractional part to consider for rounding\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(iszero(mod(mul(x, y), WAD)))\"), \": This double-negative check turns a true condition (non-zero modulus) into a false one and vice versa. So, if there is a non-zero fractional part, the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" function will return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" for non-zero and then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" again will turn that \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" into \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\"), \": Adds the result of the double \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" check to the quotient of the product divided by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \". This effectively rounds up the result if there was a non-zero fractional part.\")), mdx(\"h3\", null, \"divWad\"), mdx(\"p\", null, \"Similarly, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"divWad\"), \" function facilitates division operations between fixed point numbers. Here\\u2019s the function signature:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function divWad(uint256 x, uint256 y) internal pure returns (uint256 z)\\n\")), mdx(\"p\", null, \"Parameters are similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWad\"), \", with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"a\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"b\"), \" being the operands\"), mdx(\"p\", null, \"There are checks here as well, just like we do in other functions to make sure the results are not inconsistence or overflowed or underflowed.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"assembly {\\n    // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n    if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n        mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\\n        revert(0x1c, 0x04)\\n    }\\n    z := div(mul(x, WAD), y)\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(WAD, gt(x, div(not(0), WAD)))\"), \": This performs a check to ensure that the value of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is not too large to be multiplied by the scaling factor \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" without causing an overflow. The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt\"), \" function checks if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is greater than the largest \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"uint256\"), \" divided by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is indeed greater, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \" indicating an overflow. If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is not greater, the result would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".    \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(mul(WAD, gt(x, div(not(0), WAD))))\"), \": This is checking the result of the multiplication for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x <= uint256.max / WAD\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and multiplying by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" would still be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", resulting in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" returning \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \". If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" were too large, the result of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"gt(x, div(not(0), WAD))\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(WAD, 1)\"), \" would be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \", making \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))\"), \": This multiplies \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" with the result of the previous \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" check. If the previous result was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \", it implies that there is no risk of overflow when \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" is multiplied by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \", and it proceeds to multiply \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \" (effectively leaving \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" unchanged). If the result was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", it means that there was a risk of overflow, and multiplying \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" would yield \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero(...)\"), \": If \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"y\"), \" was \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \" or if \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x\"), \" was safe to multiply by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"WAD\"), \" without causing an overflow, then the entire multiplication expression would evaluate to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"1\"), \". If there was a potential overflow detected, the multiplication result would not be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"iszero\"), \" would return \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \".\")), mdx(\"p\", null, \"This is making sure that we make the calculations in the bounds and makes sure no unexpected behaviour happens if there is an overflow or underflow.\"), mdx(\"h3\", null, \"divWadUp\"), mdx(\"p\", null, \"This is similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"divWad\"), \" but the result is rounded up. For the other case it is rounded down. A similar approach to round up used in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mulWadUp\"), \" is being used here but with a different values.\"), mdx(\"h2\", null, \"How would this help?\"), mdx(\"h3\", null, \"Pros:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Precision\"), \": It offers higher precision for fractional numbers compared to integer arithmetic, which is crucial for financial computations that require decimal points.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Gas Efficiency\"), \": The library uses Yul, an intermediate language that compiles down to EVM bytecode, often leading to more gas-efficient contract execution than using Solidity alone.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Safety\"), \": It includes checks to prevent overflows and underflows, common pitfalls in smart contract development that can lead to significant vulnerabilities.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Convenience\"), \": Developers can perform arithmetic operations without implementing their own fixed-point math system, saving time and reducing the risk of errors.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Interoperability\"), \": It uses a standard format (wad) that is widely recognized in the Ethereum ecosystem, making it easier to integrate with other contracts and systems.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Transparency\"), \": The operations are transparent and verifiable, ensuring that contract behavior can be predicted and validated, which is essential for trust in DeFi applications.\")), mdx(\"h3\", null, \"Cons:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Complexity\"), \": For developers unfamiliar with fixed-point arithmetic, there may be a learning curve to understand how to properly use the library functions.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Code Size\"), \": Including an external library can increase the size of the contract bytecode, potentially leading to higher deployment costs.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Overhead\"), \": While the library is optimized for gas, using any library still adds a layer of complexity and gas overhead compared to native operations.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Limited Range\"), \": Fixed-point numbers have a limited range compared to floating-point numbers, which may be a limitation for some applications.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Specificity\"), \": The library is designed for a specific scaling factor (wad), which may not be suitable for all use cases requiring different levels of precision.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Upgradability\"), \": If the library is found to have a bug or requires an update, depending on how it\\u2019s integrated, it might be difficult to upgrade the smart contracts that use it.\")), mdx(\"h2\", null, \"Practical Applications\"), mdx(\"p\", null, \"These functions are indispensable when dealing with financial calculations, simulations, or any scenario demanding precision beyond integer arithmetic in your smart contracts. By understanding and utilising fixed point arithmetic through the FixedPointMathLib, you can ensure that your smart contracts operate accurately and efficiently, making your dApps more robust and reliable. Examples as follows:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"DeFi Yield Farming Platforms\"), \": Calculating rewards based on staking durations and amounts often requires precision to ensure users receive an accurate share of the yield.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Automated Market Makers (AMMs)\"), \": AMMs use complex formulas like the constant product formula (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"x * y = k\"), \") for liquidity pools.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Token Vesting Contracts\"), \": When tokens are vested, they might be released continuously over time, which could require division to calculate the fraction of tokens to release at any given point.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Oracles\"), \": Price oracles that feed external data (like currency exchange rates) into the blockchain often require high precision. When these rates are used to determine transaction values or contract terms, fixed-point arithmetic helps maintain accuracy.\")), mdx(\"p\", null, \"Also other examples include \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Insurance Contracts\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Bonding Curves\"), \",  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Interest Rate Models\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stablecoin Pegs\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Financial Derivatives\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Scientific Computations\"), \",  \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Gaming and Gambling Contracts\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Fractional NFTs\")), mdx(\"p\", null, \"In conclusion, FixedPointMathLib\\u2019s functions are vital tools in the toolkit of a Solidity developer aiming to tackle complex arithmetic scenarios in smart contract development. Through a deep understanding of these functions and fixed point arithmetic, you\\u2019re well on your way to mastering the mathematical underpinnings of Solidity and developing sophisticated smart contracts for the Ethereum blockchain.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":["3572198028","3765610985"]}